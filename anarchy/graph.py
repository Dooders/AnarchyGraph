"""

TODO
----
- Small-World Graph
    Description: A graph characterized by short path lengths and high clustering, 
    often generated by the Watts-Strogatz model.
    Use Cases: Social network analysis and the study of efficient communication 
    networks.
- Multigraph
    Description: A graph where multiple edges (parallel edges) can exist between the 
    same set of vertices.
    Use Cases: Transportation networks and network reliability studies.
- Hypergraph
    Description: A generalization of a graph where an edge (called a hyperedge) can 
    connect any number of vertices.
    Use Cases: Representing complex relationships in data sets, such as database 
    modeling and VLSI design.
"""

import json
import random
from collections import deque

import graphviz

from anarchy.node import Node


class Graph(dict):
    """
    Dict-like object to contain nodes

    Intended to be subclassed by other graph types.

    Parameters
    ----------
    node_count : int
        The number of nodes in the graph.

    Methods
    -------
    random : Node
        Returns a random node from the graph.
    to_dict : dict
        Returns the graph as a dictionary.
    to_json : str
        Returns the graph as a JSON string.
    to_adjacency_matrix : list[list[int]]
        Returns the graph as an adjacency matrix.
    to_adjacency_list : dict
        Returns the graph as an adjacency list.
    to_edge_list : list[tuple[int, int]]
        Returns the graph as an edge list.
    draw : bytes
        Returns the graph as a PNG image.

    Properties
    ----------
    nodes : list[Node]
        Returns the list of nodes in the graph.

    TODO
    ----
    - to_dot method
    - any other to_methods
    - any from_methods???
    """

    def __init__(self, node_count: int = 100) -> None:
        super().__init__()
        self.node_count = node_count
        for i in range(node_count):
            self[i] = Node(i)

    def random(self) -> "Node":
        """Returns a random node from the graph."""
        return random.choice(list(self.values()))

    def add_edge(self, node1: int, node2: int, edge_type: str = "directed") -> None:
        """Adds an edge between two nodes."""
        self[node1].edges.add(self[node2], edge_type)

    def remove_edge(self, node1: int, node2: int) -> None:
        """Removes an edge between two nodes."""
        self[node1].edges.remove(self[node2])

    def to_dict(self, schema: str = "cytoscape") -> dict:
        """Returns the graph as a dictionary."""
        nodes = []
        edges = []
        for node in self.values():
            nodes.append({"id": node.node_id, "data": node.data})
            for edge in node.edges.values():
                edges.append(
                    {"id": edge.edge_id, "source": node.node_id, "target": edge.node_id}
                )
        return {"nodes": nodes, "edges": edges}

    def to_json(self, schema: str = "cytoscape") -> str:
        """Returns the graph as a JSON string."""
        return json.dumps(self.to_dict(schema))

    def to_adjacency_matrix(self) -> list[list[int]]:
        """Returns the graph as an adjacency matrix."""
        return [
            [int(edge in node.edges) for node in self.values()]
            for edge in self.values()
        ]

    def to_adjacency_list(self) -> dict:
        """Returns the graph as an adjacency list."""
        return {
            node.node_id: [edge.node_id for edge in node.edges.values()]
            for node in self.values()
        }

    def to_edge_list(self) -> list[tuple[int, int]]:
        """Returns the graph as an edge list."""
        return [(edge.node_id, edge.node_id) for edge in self.values()]

    def draw(self) -> bytes:
        """
        Draws the graph.

        TODO
        ----
        - Get this working
        """
        graph = graphviz.Graph()
        for node in self.values():
            graph.node(str(node.node_id), str(node.data))
        return graph.pipe(format="png")

    @property
    def nodes(self) -> list[Node]:
        """Returns the list of nodes in the graph."""
        return list(self.values())

    @property
    def density(self) -> float:
        """
        Returns the density of the graph.

        The density of a graph is the ratio of the number of edges to the maximum
        possible number of edges.
        """
        return len(self.edges) / (len(self.nodes) * (len(self.nodes) - 1))


class CompleteGraph(Graph):
    """
    Creates a complete graph with n nodes.

    Inherits from Graph class.

    Parameters
    ----------
    node_count : int
        The number of nodes in the graph.
    edge_type : str
        The type of edge to create. Can be "directed" or "undirected".
    """

    def __init__(self, node_count: int, edge_type: str = "directed") -> None:
        super().__init__(node_count)
        for i in range(node_count):
            for j in range(i + 1, node_count):
                self.add_edge(i, j, edge_type)


class SparseGraph(Graph):
    """
    Creates a sparse graph with n nodes.

    Inherits from Graph class.

    Parameters
    ----------
    node_count : int
        The number of nodes in the graph.
    sparsity : float
        The sparsity factor of the graph, between 0 and 1. 1 indicates no edges,
        0 indicates all edges.
    """

    def __init__(self, node_count: int, sparsity: float = 0.1) -> None:
        super().__init__(node_count)
        self.sparsity = sparsity
        self._create_sparse_edges()

    def _create_sparse_edges(self):
        """Create sparse edges based on the sparsity factor."""
        max_edges = self.node_count * (self.node_count - 1) // 2
        num_edges = int(max_edges * self.sparsity)
        edges_added = set()

        while len(edges_added) < num_edges:
            node1, node2 = random.sample(self.nodes, 2)
            if (
                node1.node_id != node2.node_id
                and (node1.node_id, node2.node_id) not in edges_added
            ):
                node1.add_neighbor(node2.node_id)
                node2.add_neighbor(node1.node_id)
                edges_added.add((node1.node_id, node2.node_id))
                edges_added.add((node2.node_id, node1.node_id))


class IsolatedGraph(Graph):
    """
    Creates an isolated graph with n nodes. There are no edges between nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)


class StarGraph(Graph):
    """
    Creates a star graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        for i in range(node_count):
            self[i].add_neighbor(0)


class TreeGraph(Graph):
    """
    Creates a tree graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        for i in range(1, node_count):
            parent = (i - 1) // 2
            self[i].add_neighbor(parent)
            self[parent].add_neighbor(i)


class BinaryTreeGraph(Graph):
    """
    Creates a binary tree graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        for i in range(node_count):
            left = 2 * i + 1
            right = 2 * i + 2
            if left < node_count:
                self[i].add_neighbor(left)
                self[left].add_neighbor(i)
            if right < node_count:
                self[i].add_neighbor(right)
                self[right].add_neighbor(i)


class CycleGraph(Graph):
    """
    Creates a cycle graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        for i in range(node_count):
            self[i].add_neighbor((i + 1) % node_count)


class PathGraph(Graph):
    """
    Creates a path graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        for i in range(node_count - 1):
            self[i].add_neighbor(i + 1)


class WheelGraph(Graph):
    """
    Creates a wheel graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)
        if node_count < 2:
            raise ValueError("A wheel graph must have at least 2 nodes.")

        # Connect the central node (node 0) to all other nodes
        for i in range(1, node_count):
            self[0].add_neighbor(i)
            self[i].add_neighbor(0)

        # Connect the outer nodes in a cycle
        for i in range(1, node_count):
            self[i].add_neighbor((i % (node_count - 1)) + 1)
            self[(i % (node_count - 1)) + 1].add_neighbor(i)


class GridGraph(Graph):
    """
    Creates a grid graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, rows: int, cols: int) -> None:
        node_count = rows * cols
        super().__init__(node_count)

        for row in range(rows):
            for col in range(cols):
                node = row * cols + col
                if col < cols - 1:  # Connect to the right neighbor
                    right = node + 1
                    self[node].add_neighbor(right)
                    self[right].add_neighbor(node)
                if row < rows - 1:  # Connect to the bottom neighbor
                    bottom = node + cols
                    self[node].add_neighbor(bottom)
                    self[bottom].add_neighbor(node)


class BiPartiteGraph(Graph):
    """
    Creates a bi-partite graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)

        if node_count % 2 != 0:
            raise ValueError("A bi-partite graph must have an even number of nodes.")

        # Connect nodes in two sets
        mid = node_count // 2
        for i in range(mid):
            for j in range(mid, node_count):
                self[i].add_neighbor(j)
                self[j].add_neighbor(i)


class CompleteBiPartiteGraph(Graph):
    """
    Creates a complete bi-partite graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)

        if node_count % 2 != 0:
            raise ValueError(
                "A complete bi-partite graph must have an even number of nodes."
            )

        # Connect every node in the first set to every node in the second set
        mid = node_count // 2
        for i in range(mid):
            for j in range(mid, node_count):
                self[i].add_neighbor(j)
                self[j].add_neighbor(i)


class DirectedAcyclicGraph(Graph):
    """
    Creates a directed acyclic graph with n nodes.

    Inherits from Graph class.
    """

    def __init__(self, node_count: int) -> None:
        super().__init__(node_count)

        # Create a random directed acyclic graph
        self.edges = set()
        for i in range(node_count):
            for j in range(i + 1, node_count):
                if random.choice([True, False]):
                    self[i].add_neighbor(j)
                    edges.add((i, j))

        # Ensure there are no cycles
        def has_cycle():
            visited = [False] * node_count
            rec_stack = [False] * node_count

            def cycle_util(v):
                visited[v] = True
                rec_stack[v] = True

                for neighbor in self[v].neighbors:
                    if not visited[neighbor]:
                        if cycle_util(neighbor):
                            return True
                    elif rec_stack[neighbor]:
                        return True

                rec_stack[v] = False
                return False

            for node in range(node_count):
                if not visited[node]:
                    if cycle_util(node):
                        return True
            return False

        while has_cycle():
            self.clear()
            edges = set()
            for i in range(node_count):
                for j in range(i + 1, node_count):
                    if random.choice([True, False]):
                        self[i].add_neighbor(j)
                        edges.add((i, j))


class RandomGraph(Graph):
    """
    Creates a random graph with n nodes.

    Inherits from Graph class.

    The graph is created by connecting nodes randomly, but with a probability of
    sparsity that a node is isolated.

    Parameters
    ----------
    node_count : int
        The number of nodes in the graph.
    edge_density : float
        The probability of an edge between any two nodes.
    sparsity : float
        The probability of a node being isolated.
    """

    def __init__(
        self, node_count: int = 10, edge_density: float = 0.2, sparsity: float = 0.1
    ) -> None:
        super().__init__(node_count)

        eligible_count = int(node_count * (1 - sparsity))
        max_edges = int((node_count * (node_count - 1)) * edge_density)
        eligible_nodes = random.sample(list(self.values()), eligible_count)
        count = 0
        while count <= max_edges:
            node1, node2 = random.sample(eligible_nodes, 2)
            node1.edges.add(node2, edge_type="undirected")
            count += 1
